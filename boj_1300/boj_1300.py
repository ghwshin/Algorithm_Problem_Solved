# 수의 범위가 크기 때문에 이진 탐색을 이용하게 된다.
# 주요 아이디어 : 중앙값보다 작은 수의 갯수를 세어야 한다. (작은 수의 갯수가 k - 1개인 중앙값이 정답)
# 각 행은 행의 배수의 형태이다.
# 중앙값 나누기 (행의 자리) 와 n 중 작은 값이 현재보다 작은 값의 갯수이다.
# ex) n = 3, k = 7 7 = 3 * 2 + 1이다.
# 정확한 값은 어떻게 찾는가?
# 중앙값은 (1+7)/2 = 4
# 4보다 작은 수의 개수를 행마다 구한다.
# 계산시 3 + 2 + 1 = 6이다.
# 그 갯수가 k보다 작으면 시작 위치를 중앙값 오른쪽으로 옮긴다.
# 그 갯수가 k보다 크면 종료 위치를 중앙값 왼쪽으로 옮긴다.
# 이 때, 정답은 그 중앙값이 된다.
# 이 이유는 4보다 작은 수의 갯수가 6이므로 중앙값은 6번째 수보다 클 수 없기 때문이다. (6바로 밑)
n = int(input())
k = int(input())
start = 1
end = k
result = 0
while start <= end:
    mid = (start + end) // 2
    count = 0
    for i in range(1, n + 1):
        count += min(n, (mid // i))
    if count < k:
        start = mid + 1
    else:
        result = mid
        end = mid - 1
print(result)
